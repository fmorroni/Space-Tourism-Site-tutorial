/* ------------------- */
/* Custom properties   */
/* ------------------- */

:root {
    /* ------ */
    /* Colors */
    /* ------ */

    /* Declares the properties as just the hsl values (as opposed to doing for example
       --clr-dark: hsl(230 35% 7%) directly) because apparently this way it's easier
       to later modify the a value.*/
    --clr-dark: 230 35% 7%;
    --clr-light: 231 77% 90%;
    --clr-white: 0 0% 100%;
    
    /* ---------- */
    /* font-sizes */
    /* ---------- */

    /* The syntax is the same as in the font-weight system. 100 through 900 indicate increasing levels of
       weights (or in this case, sizes), with 400 being the normal value (the one used for generic/body text). */
    
    /* The figma design gives font sizes in pixels, but for accessibility reasons we'll use rems (for example
       if the user has set up the browser to show a bigger font to see better, pixel sizes can potentially
       override those settings while rems will take that into account).
       Here our normal font-size is 18px, as the default size for the html element is 16px, the value in rems
       will be (18/16)rem = 1.125rem. */
    
    /* it's better to use rems. */
    --fs-900: 9.375rem;
    --fs-800: 6.25rem;
    --fs-700: 3.5rem;
    --fs-600: 2rem;
    --fs-500: 1.75rem;
    --fs-400: 1.125rem;
    --fs-300: 1rem;
    --fs-200: 0.875rem;
    
    /* ------------- */
    /* font-families */
    /* ------------- */

    /* Read https://www.masterclass.com/articles/font-family-guide#the-types-of-font-families for a explanation on font families. */

    --ff-serif: "Bellefair", serif;
    --ff-sans-cond: "Barlow Condensed", sans-serif;
    --ff-sans-normal: "Barlow", sans-serif;

    /* Note: character spacings could also be a good candidate for setting as custom properties, but that's not something that usually
       changes so it's also fine to just add them as regular values. */
}

/* ================ */
/* RESET            */
/* ================ */

/* https://piccalil.li/blog/a-modern-css-reset/ */

/* Box sizing rules. */
*, *::before, *::after {
    box-sizing: border-box;
}

/* Reset margins. */
body,
h1,
h2,
h3,
h4,
h5,
p,
figure,
picture {
    margin: 0;
}

/* In order to remove the default boldness of headings (it's not necessary for paragraphs but it's also not bad so...) */
h1,
h2,
h3,
h4,
h5,
h6,
p {
    font-weight: 400;
}

h1,
h2,
h3,
h4 {
    font-family: var(--ff-serif);
}

h1 {
    font-size: var(--fs-900);
}

h2 {
    font-size: var(--fs-800);
}

h3 {
    font-size: var(--fs-700);
}

h4 {
    font-size: var(--fs-600);
}

h5 {
    font-family: var(--ff-sans-cond);
    font-size: var(--fs-500);
    /* ls4.75px+tab */
    letter-spacing: 4.75px;
    color: hsl(var(--clr-light));
}

/* Core body setup. */
body {
    /* Make the body height match the viewport size (window size) */
    min-height: 100vh;
    /* This basically makes the site load faster (not sure what the drawbacks are tho)*/
    text-rendering: optimizeSpeed;
    /* Default is 1.2 and it's too low. */
    line-height: 1.5;

    /* I can do f-f+tab then ffn+tab to do it super fastu */
    font-family: var(--ff-sans-normal);
    /* Here fz+tab and fs4+tab do the trick */
    font-size: var(--fs-400);

    /* bg-c+tab and hvcd+tab */
    background-color: hsl(var(--clr-dark));
    /* c+tab+esc (the ones that have a value autocompleted by emmet need an esc for the following autocomplete) and hvcw+tab */
    color: hsl(var(--clr-white));
}

/* make images easier to work with. */
img,
picture {
    /* Makes it so images get smaller when the viewport gets smaller than the original width. */
    max-width: 100%;
    /* By default images are of display type inline-block, this adds a little spacing on the
       bottom of the image that is annoying. */
    display: block;
}

/* Most elements inherit font properties, which is convenient, but form elements don't. This
   makes form elements easier to work with. */
input,
button,
textarea,
select {
    font: inherit;
}

/*
Remove animations for people who've turned them off. It's mostly to increase accessibility of the site.
(this is a browser/os setting, not an in-site one)
They are tagged as !important so this settings will prevail no matter what other settings we have.
*/
@media (prefers-reduced-motion: reduce) {
    *,
    *::before,
    *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
    }
}

/* ------------------- */
/* Utility classes     */
/* ------------------- */

.clr-info {
    --gap: 4rem;
}

.column {
    /* flex-basis: 100% makes the columns have the same width. For why this is see https://youtu.be/u044iM9xsWU?t=892 */
    flex-basis: 100%; /* would be the same as flex: 0 1 100% or flex: 1 1 0 or flex: 1 */
    --flow-space: 2rem;
}

.container {
    /* -inline only takes into account the values in the writing-mode direction. */
    padding-inline: 2em; /* same as padding: 0 2em; if writing-mode is horizontal. */
    margin-inline: auto; /* same as margin: 0 2em; if writing-mode is horizontal. */
    max-width: 80rem; /* could be set with a custom property (the var() thingy) but 
                         it's not necessary if we want the same width for all pages. */
}

.flex {
    display: flex;
    gap: var(--gap, 1rem);
}

/* .flow > * + * selects any element that is the adjacent sibling (meaning that it comes directly after) of 
   any other element, when those elements are the children of an element of class flow.
   
   It could also be done using the selector .flow > *:not(:first-child), which selects any element that is 
   not the first child. However, the :first-child pseudo-class adds specificity, which we don't really want
   (the .flow selector already adds the specificity we need) because it may make it more difficult to override
   the settings via another class.
   Note: the :not() pseudo-class doesn't add specificity of its own.
   
   To solve the specificity problem of the above selector we can use the :where() pseudo-class, which takes a 
   selector list as its argument, and selects any element that can be selected by one of the selectors in that list.
   The advantage of :where() is that it always has 0 specificity regardless of the selectors in its argument list.
   So the selector would end up being .flow > *:where(:not(:first-child)).
   The only advantage of this selector over * + * is its readability, but if you actually know your selectors and
   combinators then there should be no problem. */
.flow > * + * {
    /* outline: 1px solid red; */
    margin-top: var(--flow-space, 1rem);
}

.grid {
    display: grid;
    gap: var(--gap, 1rem);
}

.numbered-title {
    font-family: var(--ff-sans-cond);
    font-size: var(--fs-500);
    letter-spacing: 4.75px;
    text-transform: uppercase;
}

/* Note: the > (Child combinator) here indicates that only spans that are direct children of an element with
class numbered-title should be selected. If I used .numbered-title span {...} instead, it would select any
span that is descendant of an element with class numbered-title, meaning it could be a grandchild, or
grand-grandchild, etc. (the ' ' (space) combinator is called Descendant combinator). */
.numbered-title > span {
    color: hsl(var(--clr-white)/0.25);
    margin-right: 1em;
    font-weight: bold;
}

/* Screen reader only. For accessibility. It's meant to add extra information to certain elements
that may have a clear purpose visually but wouldn't say much when read with a screen reader. */
.sr-only {
    /* clipping can only be used with absolute positioning */
    position: absolute;
    
    /* Not sure why width and height are 1px instead of 0 */
    width: 1px;
    height: 1px;
    padding: 0;
    
    /* Also not sure why the negative margin. I think it makes the element stick more to the corner
    but don't know why that matters if the element has basically no dimensions. */
    margin: -1px;

    /* The overflow property specifies whether to clip the content or to add scrollbars when
    the content of an element is too big to fit in the specified area.
    hidden - The overflow is clipped, and the rest of the content will be invisible. */
    overflow: hidden;

    /* Make the visible area of the element be a circle of radius 0 (aka make the element invisible).

    Clipping to a 0 area shape has the same effect as using visibility: hidden
    however, visibility:hidden also hides the element from screen readers.

    display:none is similar to visibility:hidden but this declaration doesn't maintain the
    area of the element in place. */
    clip-path: circle(0);

    /* The white-space property sets how white space inside an element is handled.
    nowrap - Collapses white space as for normal, but suppresses line breaks
    (text wrapping) within the source. */
    white-space: nowrap;
    border: 0;
  }

/* colors */

.bg-dark { background-color: hsl(var(--clr-dark)); }
.bg-light { background-color: hsl(var(--clr-light)); }
.bg-white { background-color: hsl(var(--clr-white)); }

.txt-dark { color: hsl(var(--clr-dark)); }
.txt-light { color: hsl(var(--clr-light)); }
.txt-white { color: hsl(var(--clr-white)); }

/* typography */

.ff-serif { font-family: var(--ff-serif); } 
.ff-sans-cond { font-family: var(--ff-sans-cond); } 
.ff-sans-normal { font-family: var(--ff-sans-normal); } 

/* Not sure why Kevin doesn't use rems here */
.letter-spacing-1 { letter-spacing: 4.75px; } 
.letter-spacing-2 { letter-spacing: 2.7px; } 
.letter-spacing-3 { letter-spacing: 2.35px; } 

/* Headings all seem to be written in full uppercase so this can be used to make sure text is uppercase
no matter how we write it. */
.uppercase { text-transform: uppercase; }

.fs-900 { font-size: var(--fs-900); }
.fs-800 { font-size: var(--fs-800); }
.fs-700 { font-size: var(--fs-700); }
.fs-600 { font-size: var(--fs-600); }
.fs-500 { font-size: var(--fs-500); }
.fs-400 { font-size: var(--fs-400); }
.fs-300 { font-size: var(--fs-300); }
.fs-200 { font-size: var(--fs-200); }

.fs-900, h1,
.fs-800, h2,
.fs-700, h3,
.fs-600, h4 {
    line-height: 1.1;
}

/* ------------------- */
/* Components         */
/* ------------------- */

/* My hacky, ignorant method. */
/* .large-button {
    display: inline-block;
    text-align: center;
    --size: calc(100% + 2em*2);
    width: var(--size);
    padding-top: calc(var(--size)/2 - 0.5em);
    padding-bottom: calc(var(--size)/2 + 0.5em);
    height: 0;
    border-radius: 50%;

    Just to check that the text was centered vertically.
    background: linear-gradient(to bottom, blue, blue 49.9%, red 50.1%, red 100%);
} */


/* Kevin's chad, educated method. */
.large-button {
    position: relative;
    /* display: gird allows us to use place-items: center. Flex also works, not sure if it changes anything in this case. */
    display: grid;
    place-items: center;
    padding: 0 2em;
    border-radius: 50%;
    aspect-ratio: 1;
    /* Removes the underline. */
    text-decoration: none;
}

/* ::after is a pseudo-element that gets appended right after the element that's being selected. In this it will get appended to
   elements of class large-button that are being hovered over. */
.large-button:hover::after {
    position: absolute;
    content: attr(data-text);
    aspect-ratio: 1;
    z-index: -1;
    display: grid;
    place-items: center;
    background-color: hsl(var(--clr-white)/.2);
    padding: 0 4.7em;
    border-radius: 50%;
}

/* Doesn't work, pseudo-elements don't have pseudo-classes. Even if it worked this would only activate if the pseudo-element is being
   hovered over, which doesn't necessarily have the same size as the actual element. */
/* .large-button::after:hover {
    background-color: red;
    padding: 0 4.7em;
    border-radius: 50%;
} */